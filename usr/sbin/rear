#!/bin/bash
# $Id$
#
# Relax & Recover
#
#    Relax & Recover is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.

#    Relax & Recover is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License
#    along with Relax & Recover; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#
# Authors: 
# Schlomo Schapiro <rear at schlomo.schapiro.org> [GSS]
# Gratien D'haese  <gdha at sourceforge.net> [GD]

# Versioning
PRODUCT="Relax & Recover"
VERSION="0.0.0"
RELEASE_DATE='$Date$'
# remove SVN related junk from release date
RELEASE_DATE="${RELEASE_DATE#\$Date: }"
RELEASE_DATE="${RELEASE_DATE% (}"

COPYRIGHT="Copyright (C) 2006-2011
        Schlomo Schapiro, Immobilien Scout GmbH
        Gratien D'haese, IT3 Consultants"
STARTTIME=$SECONDS

# Allow workflows to set the exit code to a different value.
EXIT_CODE=0

# Program directories - they must be set here. Everything else is then dynamic

SHARE_DIR="/usr/share/rear"
CONFIG_DIR="/etc/rear"
VAR_DIR="/var/lib/rear"
CMD_OPTS=( "$@" )

# are we root ?
if [ $(id --user) -ne 0 ]; then
	echo  "** ERROR **	$PRODUCT needs ROOT privileges!"
	exit 1
fi

# get full path to main script
SCRIPT_FILE="$(readlink -f $(type -p "$0" || echo "$0"))"

if ! type -p pidof >/dev/null ; then
	echo 1>&2 "** ERROR **        Required program 'pidof' missing"
	exit 1
fi
# do not run if another instance is running. pidof -x will always report at least $$
if [ $$ != "$(pidof -x "$SCRIPT_FILE")" ] ; then
        echo 1>&2 "** ERROR **        $SCRIPT_FILE is already running, not starting again"
        exit 1
fi


case $- in
	*i*) BATCHMODE=true  ;;
	  *) BATCHMODE=false ;;
esac

# make sure that we use only english
export LC_CTYPE=C LC_ALL=C LANG=C

# include default config
. $SHARE_DIR/conf/default.conf

test -r "$LOGFILE" && mv -f "$LOGFILE" "$LOGFILE".old 2>/dev/null # keep old log file
exec 2>"$LOGFILE" || echo "ERROR: Could not create $LOGFILE" 1>&2

# include functions
for script in $SHARE_DIR/lib/*.sh ; do
	. $script
done



USAGE="$( basename "$0") [Options] <command> [command options ...]"'
'"$PRODUCT Version $VERSION / $RELEASE_DATE"'
'"$COPYRIGHT"'
'"$PRODUCT"' comes with ABSOLUTELY NO WARRANTY; for details 
see the GNU General Public License at http://www.gnu.org/licenses/gpl.html

Available Options:
-V			version information
-d			debug mode
-D			debugscript mode
-S			Step-by-step mode
-s			Simulation mode (shows the scripts included)
-q			Quiet mode
-r a.b.c-xx-yy		kernel version to use (current: '"$KERNEL_VERSION"')

List of commands:
'"$(
for w in ${WORKFLOWS[@]} ; do
	description=WORKFLOW_${w}_DESCRIPTION
	test "${!description}" && printf "%-24s%s\n" $w "${!description}"
done
)"

test $# -eq 0 -o "${*//*--help*/--help}" == "--help" && Usage

STEPBYSTEP=
SIMULATE=
QUIET=

# Parse options
while getopts "VhdDSsqr:" Option
do
	case $Option in
	h ) Usage ;;
	V ) Print "$PRODUCT Version $VERSION / $RELEASE_DATE\n" ; exit 0 ;;
	v ) VERBOSE=1 ;;
	d ) DEBUG=1 ; VERBOSE=1 ; kill -PWR $ProgressPID ;;
	D ) DEBUGSCRIPTS=1 ;;
	s ) SIMULATE=1 ;;
	S ) STEPBYSTEP=1 ;;
	q ) QUIET=1 ;;
	r ) KERNEL_VERSION="$OPTARG" ;;
	* ) Error "Unknown Option $Option specified." ;;
	esac
done
shift $(($OPTIND - 1))
# Move argument pointer to next.

WORKFLOW=$1 ; shift # not "$1" to get rid of compound commands

ARGS=( "$@" )

test "$WORKFLOW" ||  Usage 

v=""
verbose=""
# Prepare stuff
if test "$VERBOSE" ; then
	v="-v"
	verbose="--verbose"
fi


LogPrint "$PRODUCT Version $VERSION / $RELEASE_DATE"
test "$SIMULATE" && LogPrint "Simulation mode activated, ReaR base directory: $SHARE_DIR"
Log "Command line options: $0 ${CMD_OPTS[@]}"

# set some bash options
shopt -s nullglob extglob
hash -r

# All workflows need to read the configurations first.
# Combine configuration files
Log "Combining configuration files"
Source "$CONFIG_DIR/os.conf"	# use this file to manually override the OS detection
Source "$CONFIG_DIR/$WORKFLOW.conf"
SetOSVendorAndVersion
# distribution configuration files
for config in "$ARCH" "$OS" \
		"$OS_MASTER_VENDOR" "$OS_MASTER_VENDOR_ARCH" "$OS_MASTER_VENDOR_VERSION" "$OS_MASTER_VENDOR_VERSION_ARCH" \
		"$OS_VENDOR" "$OS_VENDOR_ARCH" "$OS_VENDOR_VERSION" "$OS_VENDOR_VERSION_ARCH" ; do
		if test "$config" ; then
			Source $SHARE_DIR/conf/"$config".conf
		fi
done
# user configuration files
for config in site local ; do
	Source $CONFIG_DIR/"$config".conf
done
# last thing is to overwrite variables if we are in the rescue system
Source "$CONFIG_DIR/rescue.conf" # set by rescue Stage


# change some options in debug mode
if test "$DEBUG"; then
	KEEP_BUILD_DIR=1
else
	KEEP_BUILD_DIR=
fi

# check for requirements
# do we have all required binaries ?
for f in "${REQUIRED_PROGS[@]}" ; do
	type -p "$f" >/dev/null|| Error "cannot find required program '$f'"
done

VERSION_INFO="
$PRODUCT Version $VERSION / $RELEASE_DATE
$COPYRIGHT
$PRODUCT comes with ABSOLUTELY NO WARRANTY; for details
see the GNU General Public License at http://www.gnu.org/licenses/gpl.html

Host $(uname -n) using Backup $BACKUP and Output $OUTPUT
Build date: $(date -R)
"

# create temporary work area and register removal exit task
BUILD_DIR="$( mktemp -d -t rear.XXXXXXXXXXXXXXX)" || Error "Could not create build area '$BUILD_DIR'"
QuietAddExitTask cleanup_build_area_and_end_program
Log "Using build area '$BUILD_DIR'"
ROOTFS_DIR=$BUILD_DIR/rootfs
TMP_DIR=$BUILD_DIR/tmp
mkdir -p $ROOTFS_DIR || Error "Could not create $ROOTFS_DIR"
mkdir -p $TMP_DIR || Error "Could not create $TMP_DIR"

# Check for and run the requested workflow
if type -t WORKFLOW_$WORKFLOW >/dev/null ; then
	Log "Running $WORKFLOW workflow"
	WORKFLOW_$WORKFLOW "${ARGS[@]}"
	Log "Finished running $WORKFLOW workflow"
else
	LogPrint "ERROR: The specified command '$WORKFLOW' does not exist !"
	EXIT_CODE=1
fi

exit $EXIT_CODE
